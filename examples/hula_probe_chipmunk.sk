//state_and_packet.pkt_0 = p.dst_tor
//state_and_packet.pkt_1 = p.path_util
//state_and_packet.pkt_2 = p.link_util
//state_and_packet.pkt_3 = p.cur_time_sub
//state_and_packet.pkt_4 = p.cur_time
//state_and_packet.pkt_5 = p.update
//state_and_packet.pkt_6 = p.in_port

//state_and_packet.state_0 = min_path_util[p.dst_tor]
//state_and_packet.state_1 = update_time[p.dst_tor]
//state_and_packet.state_2 = best_hop[p.dst_tor]

/*
void func(struct Packet p) {
  // TODO: Fix compiler
  p.dst_tor = p.dst_tor;

  // Set path utilization to minimum of current path utilization and link util
  if (p.path_util < p.link_util) {
    p.path_util = p.link_util;
  }

  // If path util is less than min_path_util for the dst TOR
  // (or) it's been a while since you updated the min_path_util
  // , then update min_path_util and update_time
  p.cur_time_sub = p.cur_time - KEEP_ALIVE_THRESH;
  if (min_path_util[p.dst_tor] > p.path_util) {
    min_path_util[p.dst_tor] = p.path_util;
    update_time[p.dst_tor] = p.cur_time_sub + KEEP_ALIVE_THRESH;
    p.update = 1;
  } else if (update_time[p.dst_tor] < p.cur_time_sub) {
    min_path_util[p.dst_tor] = p.path_util;
    update_time[p.dst_tor] = p.cur_time_sub + KEEP_ALIVE_THRESH;
    p.update = 1;
  }


  if (p.update) {
    best_hop[p.dst_tor] = p.in_port;
  }

  // set path utilization to whatever is in min_path_util
  // Required to multicast the packet onward.
  p.path_util = min_path_util[p.dst_tor];
}
*/

|StateAndPacket| program (|StateAndPacket| state_and_packet) {

  state_and_packet.pkt_0 = state_and_packet.pkt_0;
  if(state_and_packet.pkt_1 < state_and_packet.pkt_2){
	state_and_packet.pkt_1 = state_and_packet.pkt_2;
  }
  
  state_and_packet.pkt_3 = state_and_packet.pkt_4 - 20;

  if (state_and_packet.state_0 > state_and_packet.pkt_1) {
    state_and_packet.state_0 = state_and_packet.pkt_1;
    state_and_packet.state_1 = state_and_packet.pkt_3 + 20;
    state_and_packet.pkt_5 = 1;
  } else if (state_and_packet.state_1 < state_and_packet.pkt_3) {
    state_and_packet.state_0 = state_and_packet.pkt_1;
    state_and_packet.state_1 = state_and_packet.pkt_3 + 20;
    state_and_packet.pkt_5 = 1;
  }

  if (state_and_packet.pkt_5) {
	state_and_packet.state_2  = state_and_packet.pkt_6;
  }
  state_and_packet.pkt_1 = state_and_packet.state_0ï¼›

  return state_and_packet;
}

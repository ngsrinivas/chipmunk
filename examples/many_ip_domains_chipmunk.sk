//state_and_packet.pkt_0 = dns.rdata 
//state_and_packet.pkt_1 = dns.dip_index
//state_and_packet.pkt_2 = dns.qname

//state_and_packet.state_0 = domain_ip_pair[dns.dip_index] 
//state_and_packet.state_1 = num_of_domains[dns.rdata]
//state_and_packet.state_2 = mal_ip_list[dns.rdata]

/*
void func(struct Packet dns) {
  // TODO: Compiler bug, need to fix this
  dns.rdata = dns.rdata;

  // row-indexed 2D array implemented as a 1 D array
  dns.dip_index = dns.rdata * 1000 + dns.qname;
  // If this domain name (qname) + IP pair (rdata) has not been seen before
  if (domain_ip_pair[dns.dip_index] == 0) {
    // Increase number of the domains for this IP address (rdata)
    num_of_domains[dns.rdata] = num_of_domains[dns.rdata] + 1;

    // Say that it has been seen now
    domain_ip_pair[dns.dip_index] = 1;

    // Flag if the number of domains for this rdata has hit a threshold
    if (num_of_domains[dns.rdata] == THRESHOLD) {
      mal_ip_list[dns.rdata] = 1;
    }
  }
}
*/

|StateAndPacket| program (|StateAndPacket| state_and_packet) {
  state_and_packet.pkt_0 = state_and_packet.pkt_0;
  state_and_packet.pkt_1 = state_and_packet.pkt_0 * 1000 + state_and_packet.pkt_2;
  if (state_and_packet.state_0 == 0){
	state_and_packet.state_1 = state_and_packet.state_1 + 1;
	state_and_packet.state_0 = 1;
	if (state_and_packet.state_1 == 1000){
		state_and_packet.state_2 = 1;
	}
  }
  
  return state_and_packet;
}

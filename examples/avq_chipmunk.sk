//state_and_packet.pkt_0 = p.time
//state_and_packet.pkt_1 = p.bytes
//state_and_packet.pkt_2 = p.mark
//state_and_packet.pkt_3 = p.min
//state_and_packet.pkt_4 = p.max

//state_and_packet.state_0 = vq
//state_and_packet.state_1 = capacity
//state_and_packet.state_2 = last_time

/*
void func(struct Packet p) {
  // Update virtual queue size
  vq = ((vq - capacity * (p.time - last_time)) < 0) ? 0 : (vq - capacity * (p.time - last_time));

  // Mark or drop packet in real queue
  if (vq + p.bytes > BUFFER) {
    p.mark = 1;
  } else {
    vq = vq + p.bytes;
  }

  // Update virtual capacity
  p.min = ((capacity + ALPHA * GAMMA * CAPACITY * (p.time -last_time)) < CAPACITY) ? (capacity + ALPHA * GAMMA * CAPACITY * (p.time -last_time)) : CAPACITY;
  p.max = (p.min - ALPHA * p.bytes < 0) ? 0 : p.min - ALPHA * p.bytes;
  capacity = p.max;

  last_time = p.time;
}

*/

|StateAndPacket| program (|StateAndPacket| state_and_packet) {

  state_and_packet.state_0 = state_and_packet.state_0 + 1;
  if (state_and_packet.state_0 + state_and_packet.pkt_1 > 3) {
	state_and_packet.pkt_2 = 1;
  } else {
	state_and_packet.state_0 = state_and_packet.state_0 + state_and_packet.pkt_1;
  }

  state_and_packet.pkt_3 = ((state_and_packet.state_1 + 5 * 2 * 10 * (state_and_packet.pkt_0 - state_and_packet.state_2)) < 10) ? (state_and_packet.state_1 + 5 * 2 * 10 * (state_and_packet.pkt_0 - state_and_packet.state_2)) : 10;
  state_and_packet.pkt_4 =  (state_and_packet.pkt_3 - 5 * state_and_packet.pkt_1 < 0) ? 0 : state_and_packet.pkt_3 - 5 * state_and_packet.pkt_1;
  state_and_packet.state_1 = state_and_packet.pkt_4;
  state_and_packet.state_2 = state_and_packet.pkt_0;
  
  return state_and_packet;
}

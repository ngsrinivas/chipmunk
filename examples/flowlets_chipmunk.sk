//state_and_packet.pkt_0 = pkt.new_hop
//state_and_packet.pkt_1 = pkt.sport
//state_and_packet.pkt_2 = pkt.dport
//state_and_packet.pkt_3 = pkt.arrival
//state_and_packet.pkt_4 = pkt.id
//state_and_packet.pkt_5 = pkt.next_hop

//state_and_packet.state_0 = last_time[pkt.id]
//state_and_packet.state_1 = saved_hop[pkt.id]

/*
void flowlet(struct Packet pkt) {
  pkt.new_hop = hash3(pkt.sport,
                      pkt.dport,
                      pkt.arrival)
                % NUM_HOPS;

  pkt.id  = hash2(pkt.sport,
                  pkt.dport)
            % NUM_FLOWLETS;

  if (pkt.arrival -
      last_time[pkt.id] >
      THRESHOLD) {
    saved_hop[pkt.id] = pkt.new_hop;
  }

  last_time[pkt.id] = pkt.arrival;
  pkt.next_hop = saved_hop[pkt.id];
}

*/

|StateAndPacket| program (|StateAndPacket| state_and_packet) {

  state_and_packet.pkt_0 = hash3(state_and_packet.pkt_1,state_and_packet.pkt_2,state_and_packet.pkt_3) % 10;
  state_and_packet.pkt_4 = hash2(state_and_packet.pkt_1,state_and_packet.pkt_2) % 8000;
  if (state_and_packet.pkt_3 - state_and_packet.state_0 > 5){
	state_and_packet.state_1 = state_and_packet.pkt_0;
  }
  state_and_packet.state_0 = state_and_packet.pkt_3;
  state_and_packet.pkt_5 = state_and_packet.state_1;
  return state_and_packet;
}
